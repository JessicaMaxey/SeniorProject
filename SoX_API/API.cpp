#include <iostream>
using std::cout;
using std::endl;

#include <fstream>
using std::ifstream;

#include <string.h>
using std::string;

#include <stdio.h>

#include <unistd.h>

#include <chrono>
using std::chrono::milliseconds;

#include <signal.h>

#include "API.h"

const int NUM_LED_ROWS = 13;
const int MAX_SIZE_INPUT_RANGE = 4000;
const int MIN_SIZE_INPUT_RANGE = 22;
const string CUR_MP3_FILE = "/home/jess/Music/short.mp3";
const string SHELL_FILE_LOC = "";

API::API() : loading()
{
    endjob = 0;
    endthread = 0;
    pid = 0;
    freqfilelocation = "/home/jess/Music/mp3freq.txt";
}

void API::Start (string mp3file)
{
    endjob = true;
    loading.lock();
    
    if (freqthread == nullptr)
        freqthread = std::make_unique<thread>(ClassProxy, (void *)(this));
    
    if (pid != 0)
        kill(pid, SIGTERM);
    
    currentmp3file = mp3file;
    //These variables will be generated based on the users
    //input, but for now we have test data.
    currentmp3file = CUR_MP3_FILE;
    
    //Will read in the mp3 file and generate freq data
    SoXShellScript();
    
    //Will read the freq data generated by SoXShellScript
    //and generate data to be sent off to be turned into
    //LED instructions    
    loading.unlock();
}

void API::SoXShellScript ()
{
    //fork and save PID
    pid_t temp = fork();
    
    //takes mp3 and generates the freqencies for it using a shell script
    //on another process

    //executes script located at /home/jess/Music/mp3freq, 
    //and passes the location of the mp3 file as a arg
    if (temp)
        pid = temp;
    else
        execl("/bin/sh", "sh", "/home/jess/Music/mp3freq.sh", currentmp3file.data(), (char*)0);
}

void API::ReadMP3File ()
{
    while (endthread == 0)
    {
        loading.lock();
        
        //buffer to store the frequency/decibel data coming in
        vector<freq_and_dec_struct> freq_and_dec_buff;
        vector<float> dec_buff;

        //opening the file that is being written and storing the data
        ifstream ifs(freqfilelocation);
        string line;
        
        //whille stream is still alive
        while(ifs.good())
        {
            string frequency = "";
            string decibel = "";
            
            //read in from the file
            while(getline(ifs,line) && endjob == 0)
            {
                //reads whole line
                cout << line << endl;
                
                //splits on space
                frequency = line.substr(0, line.find(' '));
                decibel = line.substr(line.find(' ') + 2);
                
                int freqvalue = atoi(frequency.c_str());
                
                if(freqvalue >= MIN_SIZE_INPUT_RANGE && freqvalue <= MAX_SIZE_INPUT_RANGE)
                {
                    //stores in temp struct    
                    freq_and_dec_struct temp = {frequency, decibel};
                    
                    //adds to the vector        buffer 
                    //so far in the file
                    freq_and_dec_buff.emplace_back(temp);
                    
                    //clears out the varibles for next time
                    frequency = "";
                    decibel = "";
                }
                
                if (freqvalue > MAX_SIZE_INPUT_RANGE && freq_and_dec_buff.size() > 0)
                {
                    //call the math funtion, and it returns the 13
                    //chunks of decibel values for this buffer
                    FreqAndDecAVG(freq_and_dec_buff);
                    
                    while(decAVG.size() > 0)
                    {
                        if (endjob)
                            break;
                        sleep_for(milliseconds(1));
                    }
                    
                    freq_and_dec_buff.clear();
                }
            }
            
            //clears the state flags, and polls the stream
            //this way when the reading catches up with the
            //writing of the file it will contuine with it
            //instead of stopping.
            ifs.clear();            
            
            if (endjob)
                break;
        }    
        
        loading.unlock();
    }
}

void API::FreqAndDecAVG (vector<freq_and_dec_struct> & freq_and_dec_buff)
{
    int sizeofbuffer = freq_and_dec_buff.size();
    
    //set numbers to be able to divide both groups by 13 to 
    //get the number of chunks to do math on    
    int numinDECchunks = (sizeofbuffer / NUM_LED_ROWS);
    
    
    //overflow of freq and dec that do not fit into the division of 13 
    //that still needs to be taken care of
    int remaining = sizeofbuffer % NUM_LED_ROWS;

    int count = 0;
    
    float tempdec = 0;
    
    //adds up all the dec
    for (int i = 0; i < sizeofbuffer; i++)
    {
        tempdec += (atoi(freq_and_dec_buff[i].dec.c_str()));
        
        if ((i + 1) % numinDECchunks == 0)
        {
            if (remaining > 0)
            {
                i++;
                remaining--;
                tempdec += (atoi(freq_and_dec_buff[i].dec.c_str()));
            }
        
            //Find the average
            tempdec = (tempdec / numinDECchunks);
    
            //Add it to the vector 
            decAVG.emplace_back(tempdec);    
        }
        
        
    }
    
}

auto API::GetLEDFrame ()
{
    return move(decAVG);
}

void API::ClassProxy(void * context)
{
    API * api = (API *)context;
    
    api->ReadMP3File(); 
}