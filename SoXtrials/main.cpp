#include <iostream>
using std::cout;
using std::endl;

#include <fstream>
using std::ifstream;

#include <string.h>
using std::string;

#include <stdio.h>

#include <unistd.h>

#include <list>
using std::list;

#include <vector>
using std::vector;

#include <thread>
using std::move;

struct freq_and_dec_struct
{
    string freq;
    string dec;
};

void ReadMP3File (string);
void SoXShellScript (string, string);
void FreqAndDecAVG (vector<freq_and_dec_struct>);

const int NUM_LED_ROWS = 13;
const int MAX_SIZE_INPUT_RANGE = 4000;
const int MIN_SIZE_INPUT_RANGE = 22;

int main()
{
    //These variables will be generated based on the users
    //input, but for now we have test data.
    string freqfilelocation = "/home/jess/Music/mp3freq.txt";
    string mp3file = "/home/jess/Music/short.mp3";
    
    //Will read in the mp3 file and generate freq data
    SoXShellScript(freqfilelocation, mp3file);
    
    //Will read the freq data generated by SoXShellScript
    //and generate data to be sent off to be turned into
    //LED instructions
    ReadMP3File(freqfilelocation);
    
    

    return 0;
}

void SoXShellScript (string freqfilelocation, string mp3file)
{
    //takes mp3 and generates the freqencies for it using a shell script
    //on another process
    if (!fork())
    {
        //executes script located at /home/jess/Music/mp3freq, 
        //and passes the location of the mp3 file as a arg
        execl("/bin/sh", "sh", "/home/jess/Music/mp3freq.sh", mp3file.data(), (char*)0);
    }
}

void ReadMP3File (string freqfilelocation)
{
    //buffer to store the frequency/decibel data coming in
    vector<freq_and_dec_struct> freq_and_dec_buff;
    vector<float> dec_buff;

    //opening the file that is being written and storing the data
    ifstream ifs(freqfilelocation);
    string line;
    
    //whille stream is still alive
    while(ifs.good())
    {
        string frequency = "";
        string decibel = "";
        
        //read in from the file
        while(getline(ifs,line))
        {

            //reads whole line
            cout << line << endl;
            
            //splits on space
            frequency = line.substr(0, line.find(' '));
            decibel = line.substr(line.find(' ') + 2);
            
            int freqvalue = atoi(frequency.c_str());
            
            if(freqvalue >= MIN_SIZE_INPUT_RANGE && freqvalue <= MAX_SIZE_INPUT_RANGE)
            {
                //stores in temp struct    
                freq_and_dec_struct temp = {frequency, decibel};
                
                //adds to the vector buffer 
                //so far in the file
                freq_and_dec_buff.emplace_back(temp);
                
                //clears out the varibles for next time
                frequency = "";
                decibel = "";
            }
            
            if (freqvalue > MAX_SIZE_INPUT_RANGE && freq_and_dec_buff.size() > 0)
            {
                //call the math funtion, and it returns the 13
                //chunks of decibel values for this buffer
                dec_buff = FreqAndDecAVG(freq_and_dec_buff);
                 
                freq_and_dec_buff.clear();
            }
            

        }
        
        //clears the state flags, and polls the stream
        //this way when the reading catches up with the
        //writing of the file it will contuine with it
        //instead of stopping.
        ifs.clear();

            
        
        
    }
    
}

vector<float> FreqAndDecAVG (vector<freq_and_dec_struct> & freq_and_dec_buff)
{
    int sizeofbuffer = freq_and_dec_buff.size();
    
    //set numbers to be able to divide both groups by 13 to 
    //get the number of chunks to do math on    
    int numinDECchunks = (sizeofbuffer / NUM_LED_ROWS);
    
    
    //overflow of freq and dec that do not fit into the division of 13 
    //that still needs to be taken care of
    int remaining = sizeofbuffer % NUM_LED_ROWS;

    vector<float> decAVG;
    
    int count = 0;
    
    float tempdec = 0;
    
    //adds up all the dec
    for (int i = 0; i < sizeofbuff; i++)
    {
        tempdec += (atoi(freq_and_dec_buff[i].dec.c_str()));
        
        if ((i + 1) % numinDECchunks == 0)
        {
            if (remaining > 0)
            {
                i++;
                remaining--;
                tempdec += (atoi(freq_and_dec_buff[i].dec.c_str()));
            }
        
            //Find the average
            tempdec = (tempdec / numinDECchunks);
    
            //Add it to the vector 
            decAVG.emplace_back(tempdec);    
        }
        
        
    }
    

    return decAVG;
    
}
